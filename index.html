<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>虚空八卦 Pro - Ether Bagua Ultimate</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: 'Courier New', Courier, monospace; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* Video hidden, barely visible for debug */
        #video-input { position: absolute; top: 10px; left: 10px; width: 160px; height: 120px; z-index: 2; border: 1px solid #333; opacity: 0.1; transform: scaleX(-1); border-radius: 8px; pointer-events: none; mix-blend-mode: screen;}
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 10; text-align: center; pointer-events: none; transition: opacity 0.5s; }
        .spinner { width: 50px; height: 50px; border: 2px solid rgba(0, 255, 204, 0.1); border-top: 2px solid #00ffcc; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 15px; box-shadow: 0 0 15px #00ffcc; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        #ui-layer { position: absolute; bottom: 40px; left: 40px; z-index: 5; pointer-events: none; user-select: none; }
        .glass-panel { background: rgba(10, 10, 15, 0.6); padding: 20px; border: 1px solid rgba(0, 255, 204, 0.3); border-left: 4px solid #00ffcc; backdrop-filter: blur(12px); max-width: 350px; box-shadow: 0 0 30px rgba(0, 255, 204, 0.1); border-radius: 4px; }
        .status-line { margin-top: 10px; font-size: 12px; display: flex; align-items: center; gap: 8px; }
        .status-dot { width: 8px; height: 8px; background: #333; border-radius: 50%; box-shadow: 0 0 5px #333; transition: all 0.3s; }
        .status-dot.active { background: #00ffcc; box-shadow: 0 0 10px #00ffcc; }
        .status-dot.locked { background: #ff0055; box-shadow: 0 0 10px #ff0055; }
        
        .mode-badge { font-size: 10px; border: 1px solid #00ffcc; padding: 2px 6px; color: #00ffcc; border-radius: 10px; opacity: 0; transition: opacity 0.3s; }
        .mode-badge.visible { opacity: 1; }

        /* Custom scrollbar for instructions if needed */
        ::-webkit-scrollbar { width: 0px; }
    </style>
    
    <!-- Import Map for reliable Three.js module loading -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>

    <video id="video-input" autoplay playsinline></video>

    <div id="canvas-container"></div>

    <div id="loading">
        <div class="spinner"></div>
        <div id="loading-text" class="text-cyan-400 font-bold tracking-[0.2em] text-sm uppercase">Initializing Neural Link...<br>构建先天灵阵</div>
    </div>

    <div id="ui-layer">
        <div class="glass-panel">
            <h3 class="text-cyan-400 text-xl font-bold mb-1 tracking-widest uppercase flex justify-between items-center">
                ETHER BAGUA <span class="text-[10px] font-normal opacity-70">V.2.1</span>
            </h3>
            <div class="h-px w-full bg-gradient-to-r from-cyan-500/50 to-transparent mb-3"></div>
            
            <div class="space-y-3 text-xs text-gray-300 leading-relaxed font-sans">
                <div class="flex items-start gap-2">
                    <span class="text-cyan-400">01</span>
                    <p>举手显形，光标追踪掌心气场。</p>
                </div>
                <div class="flex items-start gap-2">
                    <span class="text-cyan-400">02</span>
                    <p><span class="text-white font-bold">悬停</span>在圆环上，<span class="text-white font-bold">画圆</span>即可转动。</p>
                </div>
                <div class="flex items-start gap-2">
                    <span class="text-cyan-400">03</span>
                    <p>(可选) <span class="text-white font-bold">捏合手指</span>以锁定操作。</p>
                </div>
            </div>

            <div class="status-line mt-4 pt-3 border-t border-gray-700/50">
                <div id="status-dot" class="status-dot"></div>
                <span id="status-text" class="font-mono text-cyan-400/80">SYSTEM STANDBY</span>
                <span id="mode-badge" class="mode-badge">LOCKED</span>
            </div>
        </div>
    </div>

<script type="module">
    import * as THREE from 'three';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm";

    // --- Configuration ---
    const CONFIG = {
        colors: {
            bg: 0x000000,
            primary: 0x00ffcc, // Cyber Cyan
            highlight: 0xffffff, // White hot
            locked: 0xff0055, // Alert Red
            secondary: 0x004455, 
        },
        sizes: {
            taiji: 2.2,
            innerRing: 4.5,
            outerRing: 7.0,
            floorSize: 200
        },
        physics: {
            lerpFactor: 0.15, // Smoothness of hand following
            inertiaDecay: 0.96, // How fast it stops spinning after release
            hoverThreshold: 0.15 // Pinch threshold
        },
        trigrams: [
            [1,1,1], [0,1,1], [0,1,0], [0,0,1], 
            [0,0,0], [1,0,0], [1,0,1], [1,1,0]
        ]
    };

    // --- Global State ---
    const STATE = {
        isLoaded: false,
        handDetected: false,
        isPinching: false,
        hoveredRing: null, // 'taiji', 'inner', 'outer'
        lastHoveredRing: null, // To detect entry
        lockedRing: null,
        
        // Hand Data
        handPos: new THREE.Vector3(), // Smoothed 3D pos
        rawHandPos: new THREE.Vector3(), // Raw input
        pinchDist: 1.0,

        // Rotation Physics
        rings: {
            taiji: { mesh: null, velocity: -0.005, angle: 0, lastHandAngle: 0 },
            inner: { mesh: null, velocity: 0.002, angle: 0, lastHandAngle: 0 },
            outer: { mesh: null, velocity: -0.001, angle: 0, lastHandAngle: 0 }
        }
    };

    // --- Three.js Globals ---
    let scene, camera, renderer, composer;
    let baguaGroup;
    let handVisGroup, handJoints = [], handBones = [];
    let starField;

    // --- MediaPipe Globals ---
    let handLandmarker, video;
    let lastVideoTime = -1;

    // --- Initialization ---
    async function init() {
        initThreeJS();
        createScene();
        await initMediaPipe();
        
        document.getElementById('loading').style.opacity = '0';
        setTimeout(() => document.getElementById('loading').style.display = 'none', 500);
        
        animate();
    }

    function initThreeJS() {
        const container = document.getElementById('canvas-container');
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 18);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        // --- Post Processing (Bloom) ---
        const renderScene = new RenderPass(scene, camera);
        
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = 1.2;
        bloomPass.radius = 0.5;
        bloomPass.threshold = 0.1;

        composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    function createScene() {
        const ambient = new THREE.AmbientLight(0xffffff, 0.1);
        scene.add(ambient);

        baguaGroup = new THREE.Group();
        scene.add(baguaGroup);

        const taijiTex = createTaijiTexture();
        const innerTex = createTrigramTexture(false);
        const outerTex = createTrigramTexture(true);

        const baseMat = {
            transparent: true,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
        };

        const taijiGeo = new THREE.CircleGeometry(CONFIG.sizes.taiji, 64);
        const taijiMat = new THREE.MeshBasicMaterial({ ...baseMat, map: taijiTex, color: 0xffffff });
        STATE.rings.taiji.mesh = new THREE.Mesh(taijiGeo, taijiMat);
        baguaGroup.add(STATE.rings.taiji.mesh);

        const innerGeo = new THREE.RingGeometry(CONFIG.sizes.taiji + 0.1, CONFIG.sizes.innerRing, 64);
        const innerMat = new THREE.MeshBasicMaterial({ ...baseMat, map: innerTex, color: CONFIG.colors.primary, opacity: 0.8 });
        STATE.rings.inner.mesh = new THREE.Mesh(innerGeo, innerMat);
        baguaGroup.add(STATE.rings.inner.mesh);

        const outerGeo = new THREE.RingGeometry(CONFIG.sizes.innerRing + 0.1, CONFIG.sizes.outerRing, 128);
        const outerMat = new THREE.MeshBasicMaterial({ ...baseMat, map: outerTex, color: CONFIG.colors.secondary, opacity: 0.6 });
        STATE.rings.outer.mesh = new THREE.Mesh(outerGeo, outerMat);
        baguaGroup.add(STATE.rings.outer.mesh);

        createHandVisuals();

        const starGeo = new THREE.BufferGeometry();
        const starCount = 1500;
        const posArray = new Float32Array(starCount * 3);
        for(let i=0; i<starCount*3; i++) {
            posArray[i] = (Math.random() - 0.5) * 60;
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const starMat = new THREE.PointsMaterial({
            size: 0.15, color: 0x00ffcc, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending
        });
        starField = new THREE.Points(starGeo, starMat);
        scene.add(starField);

        const grid = new THREE.GridHelper(100, 50, 0x003333, 0x001111);
        grid.rotation.x = Math.PI / 2;
        grid.position.z = -5; 
        grid.material.opacity = 0.2;
        grid.material.transparent = true;
        scene.add(grid);
    }

    function createTrigramTexture(isOuter) {
        const size = 2048;
        const cvs = document.createElement('canvas');
        cvs.width = size; cvs.height = size;
        const ctx = cvs.getContext('2d');
        const cx = size/2, cy = size/2;
        
        const count = isOuter ? 64 : 8;
        const radius = size/2 - 60;
        const step = (Math.PI * 2) / count;

        ctx.shadowColor = '#fff';
        ctx.shadowBlur = 10;

        for (let i = 0; i < count; i++) {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.rotate(i * step - Math.PI/2);
            
            const barWidth = (Math.PI * 2 * radius / count) * 0.65;
            const barHeight = isOuter ? 15 : 28;
            const gap = isOuter ? 5 : 14;
            
            let yao = isOuter ? Array(6).fill(0).map(()=>Math.random()>0.5?1:0) : CONFIG.trigrams[i % 8];

            for (let l = 0; l < yao.length; l++) {
                const isYang = yao[l] === 1;
                const yPos = -radius + (l * (barHeight + gap)) + (isOuter ? 140 : 80);

                ctx.fillStyle = '#ffffff'; 
                if (isYang) {
                    ctx.fillRect(-barWidth/2, yPos, barWidth, barHeight);
                } else {
                    const cut = barWidth * 0.15;
                    const segmentW = (barWidth - cut) / 2;
                    ctx.fillRect(-barWidth/2, yPos, segmentW, barHeight);
                    ctx.fillRect(cut/2, yPos, segmentW, barHeight);
                }
            }
            ctx.restore();
        }
        return new THREE.CanvasTexture(cvs);
    }

    function createTaijiTexture() {
        const size = 1024;
        const cvs = document.createElement('canvas');
        cvs.width = size; cvs.height = size;
        const ctx = cvs.getContext('2d');
        const cx = size/2, cy = size/2, r = size/2 - 20;

        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(cx, cy, r, -Math.PI/2, Math.PI/2); ctx.fill();
        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(cx, cy, r, Math.PI/2, -Math.PI/2); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(cx, cy-r/2, r/2, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(cx, cy+r/2, r/2, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(cx, cy-r/2, r/8, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(cx, cy+r/2, r/8, 0, Math.PI*2); ctx.fill();
        
        return new THREE.CanvasTexture(cvs);
    }

    function createHandVisuals() {
        handVisGroup = new THREE.Group();
        scene.add(handVisGroup);
        handVisGroup.visible = false;

        const jointGeo = new THREE.IcosahedronGeometry(0.12, 1);
        const jointMat = new THREE.MeshBasicMaterial({ color: CONFIG.colors.primary, depthTest: false });

        for (let i = 0; i < 21; i++) {
            const mesh = new THREE.Mesh(jointGeo, jointMat);
            if(i===4 || i===8) mesh.scale.setScalar(1.5);
            handJoints.push(mesh);
            handVisGroup.add(mesh);
        }

        const boneMat = new THREE.LineBasicMaterial({ color: CONFIG.colors.primary, transparent: true, opacity: 0.3, depthTest: false });
        const connections = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[17,18],[18,19],[19,20],[0,17]];
        
        connections.forEach(pair => {
            const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
            const line = new THREE.Line(geo, boneMat);
            line.userData = { a: pair[0], b: pair[1] };
            handBones.push(line);
            handVisGroup.add(line);
        });
    }

    function updateHandVisuals(landmarks) {
        if (!landmarks) return;
        handVisGroup.visible = true;

        const zPlane = 4;
        const scale = 16;
        const aspect = window.innerWidth / window.innerHeight;

        const positions = [];
        landmarks.forEach(lm => {
            const x = (0.5 - lm.x) * scale * (aspect > 1 ? aspect : 1);
            const y = (0.5 - lm.y) * scale / (aspect > 1 ? 1 : aspect);
            const z = zPlane - (lm.z * 5); 
            positions.push(new THREE.Vector3(x, y, z));
        });

        STATE.rawHandPos.copy(positions[8]);
        STATE.handPos.lerp(STATE.rawHandPos, CONFIG.physics.lerpFactor);

        handJoints.forEach((mesh, i) => mesh.position.copy(positions[i]));
        handBones.forEach(bone => {
            const a = positions[bone.userData.a];
            const b = positions[bone.userData.b];
            const arr = new Float32Array([a.x, a.y, a.z, b.x, b.y, b.z]);
            bone.geometry.setAttribute('position', new THREE.BufferAttribute(arr, 3));
        });

        const p1 = positions[4]; 
        const p2 = positions[8]; 
        STATE.pinchDist = p1.distanceTo(p2);
        
        const color = STATE.isPinching ? CONFIG.colors.locked : CONFIG.colors.primary;
        handJoints[4].material.color.setHex(color);
        handJoints[8].material.color.setHex(color);
    }

    async function initMediaPipe() {
        const vision = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
        );
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: {
                modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                delegate: "GPU"
            },
            runningMode: "VIDEO",
            numHands: 1
        });
        
        video = document.getElementById("video-input");
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
        video.srcObject = stream;
    }

    function processInteraction() {
        if (handLandmarker && video.videoWidth && video.currentTime !== lastVideoTime) {
            lastVideoTime = video.currentTime;
            const res = handLandmarker.detectForVideo(video, performance.now());
            
            if (res.landmarks.length > 0) {
                STATE.handDetected = true;
                updateHandVisuals(res.landmarks[0]);
                STATE.isPinching = STATE.pinchDist < CONFIG.physics.hoverThreshold;
            } else {
                STATE.handDetected = false;
                handVisGroup.visible = false;
                STATE.isPinching = false;
            }
        }

        const handR = Math.sqrt(STATE.handPos.x**2 + STATE.handPos.y**2);
        const handAngle = Math.atan2(STATE.handPos.y, STATE.handPos.x);

        // Detect Hover
        STATE.lastHoveredRing = STATE.hoveredRing;
        STATE.hoveredRing = null;
        if (STATE.handDetected) {
            if (handR < CONFIG.sizes.taiji) STATE.hoveredRing = 'taiji';
            else if (handR < CONFIG.sizes.innerRing) STATE.hoveredRing = 'inner';
            else if (handR < CONFIG.sizes.outerRing) STATE.hoveredRing = 'outer';
        }

        // Reset Angle Anchors on Hover Entry
        if (STATE.hoveredRing && STATE.hoveredRing !== STATE.lastHoveredRing) {
             STATE.rings[STATE.hoveredRing].lastHandAngle = handAngle;
        }

        // Locking Logic
        if (STATE.isPinching && STATE.hoveredRing && !STATE.lockedRing) {
            STATE.lockedRing = STATE.hoveredRing;
            STATE.rings[STATE.lockedRing].lastHandAngle = handAngle;
        } else if (!STATE.isPinching) {
            STATE.lockedRing = null;
        }

        updateRingPhysics(handAngle);
        updateUI();
    }

    function updateRingPhysics(handAngle) {
        ['taiji', 'inner', 'outer'].forEach(key => {
            const ringData = STATE.rings[key];
            const mesh = ringData.mesh;
            
            if (!mesh) return;

            let targetColor = CONFIG.colors.secondary;
            let targetOpacity = 0.5;

            // Common Angle Calculation Helper
            const calcDelta = () => {
                const delta = handAngle - ringData.lastHandAngle;
                let d = delta;
                if (d > Math.PI) d -= Math.PI * 2;
                if (d < -Math.PI) d += Math.PI * 2;
                return d;
            };

            if (STATE.lockedRing === key) {
                // PINCHED: 1:1 Direct Control
                const d = calcDelta();
                ringData.angle += d;
                ringData.velocity = d; 
                ringData.lastHandAngle = handAngle;

                targetColor = CONFIG.colors.locked;
                targetOpacity = 1.0;

            } else if (STATE.hoveredRing === key) {
                // HOVERED: 1:1 Control (Slightly smoother feel naturally due to lack of lock)
                const d = calcDelta();
                ringData.angle += d;
                ringData.velocity = d;
                ringData.lastHandAngle = handAngle;

                targetColor = CONFIG.colors.highlight;
                targetOpacity = 0.9;
            } else {
                // INERTIA / AUTO
                ringData.angle += ringData.velocity;
                ringData.velocity *= CONFIG.physics.inertiaDecay;

                const autoSpeed = (key === 'taiji' ? -0.005 : (key === 'inner' ? 0.002 : -0.001));
                if (Math.abs(ringData.velocity) < Math.abs(autoSpeed)) {
                     ringData.velocity = THREE.MathUtils.lerp(ringData.velocity, autoSpeed, 0.01);
                }

                if (key === 'inner') targetColor = CONFIG.colors.primary;
                else if (key === 'taiji') targetColor = 0xffffff;
            }

            mesh.rotation.z = ringData.angle;
            
            const curColor = new THREE.Color(targetColor);
            mesh.material.color.lerp(curColor, 0.1);
            mesh.material.opacity = THREE.MathUtils.lerp(mesh.material.opacity, targetOpacity, 0.1);
        });
    }

    function updateUI() {
        const dot = document.getElementById('status-dot');
        const text = document.getElementById('status-text');
        const badge = document.getElementById('mode-badge');

        if (!STATE.handDetected) {
            dot.className = 'status-dot';
            text.innerText = "NO SIGNAL";
            text.style.color = "#555";
            badge.classList.remove('visible');
        } else if (STATE.lockedRing) {
            dot.className = 'status-dot locked';
            text.innerText = `LOCKED: ${STATE.lockedRing.toUpperCase()}`;
            text.style.color = "#ff0055";
            badge.classList.add('visible');
            badge.innerText = "LOCKED";
            badge.style.borderColor = "#ff0055";
            badge.style.color = "#ff0055";
        } else if (STATE.hoveredRing) {
            dot.className = 'status-dot active';
            text.innerText = `ACTIVE: ${STATE.hoveredRing.toUpperCase()}`;
            text.style.color = "#00ffcc";
            badge.classList.add('visible');
            badge.innerText = "HOVER";
            badge.style.borderColor = "#00ffcc";
            badge.style.color = "#00ffcc";
        } else {
            dot.className = 'status-dot active';
            text.innerText = "DETECTED - IDLE";
            text.style.color = "#00ffcc";
            badge.classList.remove('visible');
        }
    }

    function animate() {
        requestAnimationFrame(animate);
        processInteraction();
        if(starField) starField.rotation.y += 0.0005;
        composer.render();
    }

    init();

</script>
</body>
</html>